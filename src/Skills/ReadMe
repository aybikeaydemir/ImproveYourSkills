




Infos:
*return new int [] {array[left] , array [right]};

Anagram: sort compare

TargetSum: currentSum<target left++ target<currentSum right--;

OddPair: A^B^C = C  unpaired = unpaired ^ A[i];

Shifting: (i + K) % A.length

Palindrome: for ( int i = length - 1; i >= 0; i-- )
reverse = reverse + original.charAt(i);

SmallestNotInArray: HashSet<Integer> set set.add(A[i]); for:A.length if(set.contains(i) != true)

Permutation:  HashSet per.add(A[i]); (!per.contains(i)) return 0;

findStartIndex: while(l<=r) {
m=(l+r)/2 n[m] == t && n[m-1] <t
return t;
n[m]<t  l= m +1
r=m-1;
}

mirror: a.data == b.data && areMirror(a.left, b.right)
                        && areMirror(a.right, b.left)

Fish: Stack fishes //down(1) fishes.push(A[i]);
else {
                while (!fishes.isEmpty()){
                    //upside bigger than downside fish
                    if (fishes.peek()<A[i]) {
                        numFish--;
                        fishes.pop();
                    }
                   // downside fish bigger than upside
                    if (fishes.peek()>A[i]){
                        numFish--;
                        break;
                    }
}}
